import React, { useState, useEffect, useMemo } from 'react';
/* REMOVIDO
import { initializeApp } from 'firebase/app';
import { 
  getAuth, 
  signInAnonymously, 
  signInWithCustomToken, 
  onAuthStateChanged 
} from 'firebase/auth';
import { 
  getFirestore, 
  collection, 
  addDoc, 
  onSnapshot, 
  query, 
  where, 
  doc, 
  setDoc, 
  deleteDoc,
  setLogLevel
} from 'firebase/firestore';
*/
import { 
  PieChart, 
  Pie, 
  Cell, 
  BarChart, 
  Bar, 
  XAxis, 
  YAxis, 
  Tooltip, 
  Legend, 
  ResponsiveContainer 
} from 'recharts';
import { 
  LayoutDashboard, 
  Package, 
  PlusCircle, 
  ChevronDown, 
  Search, 
  Edit2, 
  Trash2, 
  X,
  AlertCircle,
  TrendingUp,
  DollarSign,
  Users
} from 'lucide-react';

// --- Constantes de Configuração ---

// Configuração das categorias e seus campos específicos
// Isso é o coração da lógica dinâmica do formulário
const CATEGORY_DEFINITIONS = {
  "Streaming": {
    label: "Streaming (100 un)",
    fields: ["productName", "supplier", "accountPrice", "screenPrice", "purchasePrice", "salePrice", "duration", "purchaseDate", "expirationDate", "hasAddons", "addons"]
  },
  "Música & Podcast": {
    label: "Música & Podcast (10 un)",
    fields: ["productName", "supplier", "accountPrice", "access", "duration", "purchasePrice", "purchaseDate", "salePrice", "saleDate", "expirationDate"]
  },
  "Aprendizado de Idiomas": {
    label: "Aprendizado de Idiomas (10 un)",
    fields: ["productName", "supplier", "accountPrice", "access", "duration", "purchasePrice", "purchaseDate", "salePrice", "saleDate", "expirationDate"]
  },
  "Cursos Online": {
    label: "Cursos Online (50 un)",
    fields: ["productName", "supplier", "accountPrice", "access", "duration", "purchasePrice", "purchaseDate", "salePrice", "saleDate", "expirationDate"]
  },
  "Preparação para Provas e Vestibulares": {
    label: "Preparação para Provas e Vestibulares (50 un)",
    fields: ["productName", "supplier", "accountPrice", "access", "duration", "purchasePrice", "purchaseDate", "salePrice", "saleDate", "expirationDate"]
  },
  "Métodos Diversos": {
    label: "Métodos Diversos (10 un)",
    fields: ["productName", "supplier", "purchasePrice", "purchaseDate", "salePrice", "saleDate"]
  },
  "Recarga de Celular": {
    label: "Recarga de Celular (20 un)",
    fields: ["productName", "supplier", "price", "duration", "purchasePrice", "purchaseDate", "salePrice", "saleDate", "expirationDate"]
  },
  "Livros & Audiobooks": {
    label: "Livros & Audiobooks (20 un)",
    fields: ["productName", "supplier", "accountPrice", "access", "duration", "purchasePrice", "purchaseDate", "salePrice", "saleDate", "expirationDate"]
  },
  "Edição de Vídeo & Imagem": {
    label: "Edição de Vídeo & Imagem (10 un)",
    fields: ["productName", "supplier", "accountPrice", "access", "duration", "purchasePrice", "purchaseDate", "salePrice", "saleDate", "expirationDate"]
  },
  "TV Online": {
    label: "TV Online (10 un)",
    fields: ["productName", "supplier", "login", "accountPrice", "duration", "purchasePrice", "purchaseDate", "salePrice", "saleDate", "expirationDate"]
  },
  "Seguidores, Curtidas & Visualizações": {
    label: "Seguidores, Curtidas & Visualizações (3 un)",
    fields: ["productName", "supplier", "purchasePrice", "purchaseDate", "salePrice", "saleDate", "socialNetwork"]
  },
  "Inteligência Artificial": {
    label: "Inteligência Artificial (10 un)",
    fields: ["productName", "supplier", "accountPrice", "access", "duration", "purchasePrice", "purchaseDate", "salePrice", "saleDate", "expirationDate"]
  },
  "Jogos": {
    label: "Jogos (100 un)",
    fields: ["productName", "supplier", "purchasePrice", "salePrice", "purchaseDate", "saleDate"]
  },
  "Bots de Número Virtual": {
    label: "Bots de Número Virtual (40 un)",
    fields: ["productName", "supplier", "purchasePrice", "salePrice", "purchaseDate", "saleDate"]
  },
  "Planilhas": {
    label: "Planilhas (10 un)",
    fields: ["productName", "supplier", "purchasePrice", "salePrice", "purchaseDate"]
  },
  "Conteúdo Adulto": {
    label: "Conteúdo Adulto (10 un)",
    fields: ["productName", "supplier", "accountPrice", "access", "duration", "purchasePrice", "purchaseDate", "salePrice", "saleDate", "expirationDate"]
  },
  "Conteúdo Religioso": {
    label: "Conteúdo Religioso (10 un)",
    fields: ["productName", "supplier", "accountPrice", "access", "duration", "purchasePrice", "purchaseDate", "salePrice", "saleDate", "expirationDate"]
  },
  "Softwares & Licenças": {
    label: "Softwares & Licenças (20 un)",
    fields: ["productName", "supplier", "duration", "purchasePrice", "purchaseDate", "salePrice", "saleDate", "expirationDate"]
  },
  "Aplicativos Modificados": {
    label: "Aplicativos Modificados (100 un)",
    fields: ["productName", "supplier", "purchasePrice", "purchaseDate", "salePrice", "saleDate"]
  }
};

// Definição de todos os campos possíveis e seus rótulos em português
const FIELD_LABELS = {
  productName: { label: "Produto", type: "text", placeholder: "Nome do produto/serviço" },
  supplier: { label: "Fornecedor", type: "text", placeholder: "WhatsApp, Telegram ou site" },
  accountPrice: { label: "Preço (Conta)", type: "number", placeholder: "Valor da conta" },
  screenPrice: { label: "Preço (Tela)", type: "number", placeholder: "Valor da tela" },
  access: { label: "Acesso", type: "text", placeholder: "Link, usuário, etc." },
  login: { label: "Login", type: "text", placeholder: "Usuário/Senha" },
  price: { label: "Preço", type: "number", placeholder: "Preço do item" },
  purchasePrice: { label: "Preço de Compra", type: "number", placeholder: "0.00" },
  salePrice: { label: "Preço de Venda", type: "number", placeholder: "0.00" },
  duration: { label: "Duração", type: "text", placeholder: "30 dias, 1 ano..." },
  purchaseDate: { label: "Data de Compra", type: "date" },
  saleDate: { label: "Data de Venda", type: "date" },
  expirationDate: { label: "Data de Expiração", type: "date" },
  hasAddons: { label: "Possui Add-ons?", type: "select", options: ["Não", "Sim"] },
  addons: { label: "Lista/Qtde Add-ons", type: "text", placeholder: "Prime, Max ou 3" },
  socialNetwork: { label: "Rede Social", type: "select", options: ["Instagram", "TikTok", "Twitter", "YouTube", "WhatsApp", "Telegram"] }
};

const PIE_COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042', '#8884D8', '#FF00FF', '#00FFFF', '#FF0000', '#00FF00', '#0000FF'];

// --- Componentes da UI ---

/**
 * Componente Principal - App
 * Gerencia o estado global, autenticação e navegação.
 */
export default function App() {
  const [page, setPage] = useState('dashboard'); // 'dashboard' ou 'products'
  /* REMOVIDO
  const [db, setDb] = useState(null);
  const [auth, setAuth] = useState(null);
  const [userId, setUserId] = useState(null);
  const [isAuthReady, setIsAuthReady] = useState(false);
  */
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  /* REMOVIDO
  const [appId, setAppId] = useState('default-app-id');
  */

  /* REMOVIDO 
  // 1. Inicialização do Firebase e Autenticação
  useEffect(() => {
    try {
      // Pega o App ID e a Config do Firebase do ambiente
      const appIdFromEnv = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
      const firebaseConfigStr = typeof __firebase_config !== 'undefined' ? __firebase_config : '{}';
      const firebaseConfig = JSON.parse(firebaseConfigStr);

      if (!firebaseConfig.apiKey) {
        setError("Configuração do Firebase não encontrada.");
        setLoading(false);
        return;
      }
      
      setAppId(appIdFromEnv);

      const app = initializeApp(firebaseConfig);
      const authInstance = getAuth(app);
      const dbInstance = getFirestore(app);
      
      // Habilita logs de debug do Firestore
      // setLogLevel('debug');

      setDb(dbInstance);
      setAuth(authInstance);

      // Listener de autenticação
      const unsubscribe = onAuthStateChanged(authInstance, async (user) => {
        if (user) {
          setUserId(user.uid);
          setIsAuthReady(true);
        } else {
          // Tenta logar com token customizado ou anonimamente
          try {
            const token = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
            if (token) {
              await signInWithCustomToken(authInstance, token);
            } else {
              await signInAnonymously(authInstance);
            }
          } catch (authError) {
            console.error("Erro na autenticação:", authError);
            setError("Falha ao autenticar. Verifique a configuração do Firebase.");
            setLoading(false);
          }
        }
      });

      return () => unsubscribe();
    } catch (e) {
      console.error("Erro ao inicializar Firebase:", e);
      setError("Erro crítico ao carregar o app. Verifique o console.");
      setLoading(false);
    }
  }, []);

  // 2. Carregamento de Dados do Firestore
  useEffect(() => {
    if (!isAuthReady || !db || !userId) {
      return;
    }

    setLoading(true);
    
    // Caminho da coleção privada do usuário
    const collectionPath = `/artifacts/${appId}/users/${userId}/products`;
    const q = query(collection(db, collectionPath));

    const unsubscribe = onSnapshot(q, (querySnapshot) => {
      const productsData = [];
      querySnapshot.forEach((doc) => {
        productsData.push({ id: doc.id, ...doc.data() });
      });
      setProducts(productsData);
      setLoading(false);
    }, (err) => {
      console.error("Erro ao buscar dados:", err);
      setError("Não foi possível carregar os produtos. Verifique sua conexão e as regras do Firestore.");
      setLoading(false);
    });

    return () => unsubscribe();
  }, [isAuthReady, db, userId, appId]);
  */

  // 1. Carrega os produtos do localStorage ao iniciar
  useEffect(() => {
    setLoading(true);
    try {
      const savedProducts = localStorage.getItem('gestorDigitalProdutos');
      if (savedProducts) {
        setProducts(JSON.parse(savedProducts));
      }
    } catch (e) {
      console.error("Erro ao carregar produtos do localStorage:", e);
      setError("Não foi possível carregar seus dados salvos.");
    }
    setLoading(false);
  }, []);

  // 2. Salva os produtos no localStorage sempre que a lista for alterada
  useEffect(() => {
    try {
      localStorage.setItem('gestorDigitalProdutos', JSON.stringify(products));
    } catch (e) {
      console.error("Erro ao salvar produtos no localStorage:", e);
      setError("Não foi possível salvar suas alterações.");
    }
  }, [products]);

  // Funções CRUD para manipular o estado
  const saveProduct = (productData) => {
    setProducts(prevProducts => {
      const existing = prevProducts.find(p => p.id === productData.id);
      if (existing) {
        // Editar
        return prevProducts.map(p =>
          p.id === productData.id ? productData : p
        );
      } else {
        // Adicionar
        return [...prevProducts, productData];
      }
    });
  };

  const deleteProduct = (productId) => {
    setProducts(prevProducts =>
      prevProducts.filter(p => p.id !== productId)
    );
  };

  // Renderização principal
  if (error) {
    return (
      <div className="flex items-center justify-center h-screen bg-black">
        <div className="p-6 bg-gray-900 rounded-lg shadow-md text-center">
          <AlertCircle className="w-12 h-12 mx-auto text-red-500" />
          <h2 className="mt-4 text-xl font-semibold text-white">Erro ao Carregar</h2>
          <p className="mt-2 text-gray-300">{error}</p>
        </div>
      </div>
    );
  }

  /* REMOVIDO
  if (loading && !isAuthReady) {
  */
  if (loading) {
    return (
      <div className="flex items-center justify-center h-screen bg-black text-white">
        <div className="flex flex-col items-center">
          <div className="w-12 h-12 border-4 border-blue-400 border-t-transparent rounded-full animate-spin"></div>
          <p className="mt-4 text-lg">Carregando dados...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="flex h-screen bg-black font-inter">
      {/* Sidebar */}
      <nav className="w-64 bg-black text-white flex flex-col">
        <div className="p-6 text-2xl font-bold border-b border-gray-800">
          Gestor Digital
        </div>
        <ul className="flex-1 mt-6 space-y-2">
          <NavItem
            icon={<LayoutDashboard />}
            label="Dashboard"
            isActive={page === 'dashboard'}
            onClick={() => setPage('dashboard')}
          />
          <NavItem
            icon={<Package />}
            label="Gerenciar Produtos"
            isActive={page === 'products'}
            onClick={() => setPage('products')}
          />
        </ul>
        <div className="p-4 border-t border-gray-800 text-xs text-gray-500">
          {/* REMOVIDO
          <p>App ID: {appId.substring(0, 15)}...</p>
          <p>User ID: {userId ? userId.substring(0, 15) + '...' : 'N/A'}</p>
          */}
          <p>Status: Salvo localmente</p>
        </div>
      </nav>

      {/* Conteúdo Principal */}
      <main className="flex-1 overflow-y-auto p-8 text-white">
        {page === 'dashboard' && <Dashboard products={products} />}
        {page === 'products' && (
          <ProductManager 
            products={products}
            loading={loading}
            /* REMOVIDO
            db={db}
            userId={userId}
            appId={appId} 
            */
            onSaveProduct={saveProduct}
            onDeleteProduct={deleteProduct}
          />
        )}
      </main>
    </div>
  );
}

/**
 * Componente NavItem (Item da Sidebar)
 */
function NavItem({ icon, label, isActive, onClick }) {
  return (
    <li>
      <button
        onClick={onClick}
        className={`flex items-center w-full px-6 py-3 text-left transition-colors duration-200 ${
          isActive
            ? 'bg-blue-600 text-white'
            : 'text-gray-400 hover:bg-gray-800 hover:text-white'
        }`}
      >
        {React.cloneElement(icon, { className: 'w-5 h-5 mr-3' })}
        <span className="font-medium">{label}</span>
      </button>
    </li>
  );
}

/**
 * Componente Dashboard
 * Exibe gráficos e estatísticas.
 */
function Dashboard({ products }) {
  
  // Memoiza os dados dos gráficos para evitar recálculos
  const { kpiData, categoryData, salesData, expiringSoon } = useMemo(() => {
    const totalPurchase = products.reduce((sum, p) => sum + (Number(p.purchasePrice) || 0), 0);
    const totalSale = products.reduce((sum, p) => sum + (Number(p.salePrice) || 0), 0);
    const potentialProfit = totalSale - totalPurchase;
    
    const kpiData = [
      { title: "Total de Produtos", value: products.length, icon: <Package className="w-6 h-6 text-blue-500" /> },
      { title: "Valor Venda (Total)", value: `R$ ${totalSale.toFixed(2)}`, icon: <DollarSign className="w-6 h-6 text-green-500" /> },
      { title: "Lucro Potencial", value: `R$ ${potentialProfit.toFixed(2)}`, icon: <TrendingUp className="w-6 h-6 text-yellow-500" /> },
    ];
    
    const categoryCounts = products.reduce((acc, p) => {
      const categoryName = p.category || "Sem Categoria";
      acc[categoryName] = (acc[categoryName] || 0) + 1;
      return acc;
    }, {});
    
    const categoryData = Object.keys(categoryCounts).map(name => ({
      name: CATEGORY_DEFINITIONS[name]?.label || name,
      value: categoryCounts[name]
    }));

    const salesByCategory = products.reduce((acc, p) => {
      const categoryName = p.category || "Sem Categoria";
      const salePrice = Number(p.salePrice) || 0;
      acc[categoryName] = (acc[categoryName] || 0) + salePrice;
      return acc;
    }, {});

    const salesData = Object.keys(salesByCategory).map(name => ({
      name: CATEGORY_DEFINITIONS[name]?.label.split(' ')[0] || name, // Nome curto
      "Valor de Venda": salesByCategory[name]
    }));
    
    const today = new Date();
    const next7Days = new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000);
    
    const expiringSoon = products
      .filter(p => {
        if (!p.expirationDate) return false;
        try {
          const expDate = new Date(p.expirationDate + "T00:00:00"); // Adiciona T00:00:00 para datas locais
          return expDate >= today && expDate <= next7Days;
        } catch (e) {
          return false;
        }
      })
      .sort((a, b) => new Date(a.expirationDate) - new Date(b.expirationDate));

    return { kpiData, categoryData, salesData, expiringSoon };
  }, [products]);

  return (
    <div className="space-y-8">
      <h1 className="text-3xl font-bold text-gray-100">Dashboard</h1>
      
      {/* KPIs */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        {kpiData.map(item => (
          <div key={item.title} className="p-6 bg-gray-900 rounded-lg shadow-lg flex items-center space-x-4">
            <div className="p-3 bg-gray-800 rounded-full">{item.icon}</div>
            <div>
              <p className="text-sm font-medium text-gray-400">{item.title}</p>
              <p className="text-2xl font-bold text-white">{item.value}</p>
            </div>
          </div>
        ))}
      </div>
      
      {/* Gráficos */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
        <div className="p-6 bg-gray-900 rounded-lg shadow-lg">
          <h2 className="text-xl font-semibold text-white mb-4">Produtos por Categoria</h2>
          <ResponsiveContainer width="100%" height={300}>
            <PieChart>
              <Pie
                data={categoryData}
                dataKey="value"
                nameKey="name"
                cx="50%"
                cy="50%"
                outerRadius={110}
                fill="#8884d8"
                labelLine={false}
                label={({ name, percent }) => `${(percent * 100).toFixed(0)}%`}
              >
                {categoryData.map((entry, index) => (
                  <Cell key={`cell-${index}`} fill={PIE_COLORS[index % PIE_COLORS.length]} />
                ))}
              </Pie>
              <Tooltip 
                formatter={(value) => [value, "Produtos"]} 
                contentStyle={{ backgroundColor: '#111827', border: 'none', borderRadius: '8px' }}
                itemStyle={{ color: '#d1d5db' }}
              />
              <Legend wrapperStyle={{ color: '#9ca3af' }} />
            </PieChart>
          </ResponsiveContainer>
        </div>

        <div className="p-6 bg-gray-900 rounded-lg shadow-lg">
          <h2 className="text-xl font-semibold text-white mb-4">Valor de Venda por Categoria</h2>
          <ResponsiveContainer width="100%" height={300}>
            <BarChart data={salesData} margin={{ top: 5, right: 0, left: 0, bottom: 5 }}>
              <XAxis dataKey="name" fontSize={10} tick={{ fill: '#9ca3af' }} />
              <YAxis tick={{ fill: '#9ca3af' }} />
              <Tooltip 
                formatter={(value) => [`R$ ${value.toFixed(2)}`, "Valor de Venda"]} 
                contentStyle={{ backgroundColor: '#111827', border: 'none', borderRadius: '8px' }}
                itemStyle={{ color: '#d1d5db' }}
              />
              <Legend wrapperStyle={{ color: '#9ca3af' }} />
              <Bar dataKey="Valor de Venda" fill="#00C49F" />
            </BarChart>
          </ResponsiveContainer>
        </div>
      </div>

      {/* Tabela de Itens Expirando */}
      <div className="p-6 bg-gray-900 rounded-lg shadow-lg">
        <h2 className="text-xl font-semibold text-white mb-4">Itens Expirando em Breve (Próximos 7 dias)</h2>
        {expiringSoon.length === 0 ? (
          <p className="text-gray-400">Nenhum item expirando nos próximos 7 dias.</p>
        ) : (
          <div className="overflow-x-auto">
            <table className="w-full text-left">
              <thead>
                <tr className="bg-gray-800">
                  <th className="p-3 text-sm font-semibold text-gray-300">Produto</th>
                  <th className="p-3 text-sm font-semibold text-gray-300">Categoria</th>
                  <th className="p-3 text-sm font-semibold text-gray-300">Data de Expiração</th>
                  <th className="p-3 text-sm font-semibold text-gray-300">Preço Venda</th>
                </tr>
              </thead>
              <tbody className="divide-y divide-gray-700">
                {expiringSoon.map(p => (
                  <tr key={p.id} className="hover:bg-gray-800">
                    <td className="p-3 text-sm text-gray-200">{p.productName}</td>
                    <td className="p-3 text-sm text-gray-200">{CATEGORY_DEFINITIONS[p.category]?.label || p.category}</td>
                    <td className="p-3 text-sm text-red-400 font-medium">{formatDate(p.expirationDate)}</td>
                    <td className="p-3 text-sm text-gray-200">R$ {Number(p.salePrice || 0).toFixed(2)}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </div>
    </div>
  );
}

/**
 * Componente ProductManager
 * Gerencia a lista, filtros e modal de adição/edição.
 */
function ProductManager({ products, loading, /* db, userId, appId, */ onSaveProduct, onDeleteProduct }) {
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingProduct, setEditingProduct] = useState(null);
  const [filterCategory, setFilterCategory] = useState('all');
  const [searchTerm, setSearchTerm] = useState('');

  // Memoiza a lista de produtos filtrados
  const filteredProducts = useMemo(() => {
    return products.filter(p => {
      const categoryMatch = filterCategory === 'all' || p.category === filterCategory;
      const searchMatch = !searchTerm || 
        (p.productName && p.productName.toLowerCase().includes(searchTerm.toLowerCase())) ||
        (p.supplier && p.supplier.toLowerCase().includes(searchTerm.toLowerCase()));
      return categoryMatch && searchMatch;
    });
  }, [products, filterCategory, searchTerm]);

  const handleAddNew = () => {
    setEditingProduct(null);
    setIsModalOpen(true);
  };

  const handleEdit = (product) => {
    setEditingProduct(product);
    setIsModalOpen(true);
  };

  const handleDelete = async (productId) => {
    // Substitui o confirm() por uma lógica de UI (a ser implementada, por ex. um 2º modal)
    // Por enquanto, apenas executa a deleção.
    /* REMOVIDO
    if (!db || !userId) return;
    try {
      const docPath = `/artifacts/${appId}/users/${userId}/products/${productId}`;
      await deleteDoc(doc(db, docPath));
    } catch (e) {
      console.error("Erro ao deletar produto:", e);
      // Aqui você poderia setar um estado de erro para o usuário
    }
    */
    // Apenas chama a função passada por props
    onDeleteProduct(productId);
  };

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-3xl font-bold text-gray-100">Gerenciar Produtos</h1>
        <button
          onClick={handleAddNew}
          className="flex items-center px-4 py-2 bg-blue-600 text-white rounded-lg shadow-md hover:bg-blue-700 transition-colors"
        >
          <PlusCircle className="w-5 h-5 mr-2" />
          Adicionar Produto
        </button>
      </div>

      {/* Filtros */}
      <div className="p-4 bg-gray-900 rounded-lg shadow-md flex items-center space-x-4">
        <div className="flex-1 relative">
          <input
            type="text"
            placeholder="Buscar por nome ou fornecedor..."
            className="w-full pl-10 pr-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 bg-gray-800 text-white border-gray-700 placeholder-gray-500"
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
          />
          <Search className="w-5 h-5 text-gray-400 absolute left-3 top-1/2 -translate-y-1/2" />
        </div>
        <div className="relative">
          <select
            className="appearance-none w-64 bg-gray-800 text-white border-gray-700 border rounded-lg pl-4 pr-10 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
            value={filterCategory}
            onChange={(e) => setFilterCategory(e.target.value)}
          >
            <option value="all">Todas as Categorias</option>
            {Object.keys(CATEGORY_DEFINITIONS).map(key => (
              <option key={key} value={key}>{CATEGORY_DEFINITIONS[key].label}</option>
            ))}
          </select>
          <ChevronDown className="w-5 h-5 text-gray-400 absolute right-3 top-1/2 -translate-y-1/2 pointer-events-none" />
        </div>
      </div>

      {/* Tabela de Produtos */}
      <DynamicProductTable 
        products={filteredProducts}
        loading={loading}
        onEdit={handleEdit}
        onDelete={handleDelete}
      />

      {/* Modal */}
      {isModalOpen && (
        <ProductModal
          productToEdit={editingProduct}
          onClose={() => setIsModalOpen(false)}
          /* REMOVIDO
          db={db}
          userId={userId}
          appId={appId}
          */
          onSave={onSaveProduct}
        />
      )}
    </div>
  );
}

/**
 * Componente DynamicProductTable
 * Exibe a tabela de produtos, adaptando colunas se necessário (simplificado por agora).
 */
function DynamicProductTable({ products, loading, onEdit, onDelete }) {
  
  // Colunas comuns a serem exibidas
  const columns = [
    { key: "productName", label: "Produto" },
    { key: "category", label: "Categoria" },
    { key: "supplier", label: "Fornecedor" },
    { key: "purchasePrice", label: "Preço Compra" },
    { key: "salePrice", label: "Preço Venda" },
    { key: "expirationDate", label: "Expiração" },
  ];

  const formatCell = (product, colKey) => {
    const value = product[colKey];
    switch(colKey) {
      case 'category':
        return CATEGORY_DEFINITIONS[value]?.label.split(' (')[0] || value || '-';
      case 'purchasePrice':
      case 'salePrice':
        return `R$ ${Number(value || 0).toFixed(2)}`;
      case 'expirationDate':
        return value ? formatDate(value) : '-';
      default:
        return value || '-';
    }
  };

  return (
    <div className="bg-gray-900 rounded-lg shadow-lg overflow-hidden">
      <div className="overflow-x-auto">
        <table className="w-full text-left">
          <thead className="bg-gray-800">
            <tr>
              {columns.map(col => (
                <th key={col.key} className="p-4 text-sm font-semibold text-gray-300 uppercase">
                  {col.label}
                </th>
              ))}
              <th className="p-4 text-sm font-semibold text-gray-300 uppercase text-right">Ações</th>
            </tr>
          </thead>
          <tbody className="divide-y divide-gray-700">
            {loading ? (
              <tr>
                <td colSpan={columns.length + 1} className="p-4 text-center text-gray-400">
                  Carregando produtos...
                </td>
              </tr>
            ) : products.length === 0 ? (
              <tr>
                <td colSpan={columns.length + 1} className="p-4 text-center text-gray-400">
                  Nenhum produto encontrado.
                </td>
              </tr>
            ) : (
              products.map(product => (
                <tr key={product.id} className="hover:bg-gray-800">
                  {columns.map(col => (
                    <td key={col.key} className="p-4 text-sm text-gray-200 whitespace-nowrap">
                      {formatCell(product, col.key)}
                    </td>
                  ))}
                  <td className="p-4 text-sm text-gray-200 whitespace-nowrap text-right">
                    <button onClick={() => onEdit(product)} className="text-blue-400 hover:text-blue-300 mr-3 p-1">
                      <Edit2 className="w-5 h-5" />
                    </button>
                    <button onClick={() => onDelete(product.id)} className="text-red-400 hover:text-red-300 p-1">
                      <Trash2 className="w-5 h-5" />
                    </button>
                  </td>
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>
    </div>
  );
}

/**
 * Componente ProductModal
 * Formulário dinâmico para adicionar ou editar produtos.
 */
function ProductModal({ productToEdit, onClose, /* db, userId, appId, */ onSave }) {
  const [formData, setFormData] = useState(
    productToEdit || { category: "Streaming" } // Default ou produto existente
  );
  const [selectedCategory, setSelectedCategory] = useState(
    productToEdit?.category || "Streaming"
  );
  const [isSaving, setIsSaving] = useState(false);
  
  const [fieldsToRender, setFieldsToRender] = useState(
    CATEGORY_DEFINITIONS[selectedCategory].fields
  );

  // Atualiza os campos do formulário quando a categoria muda
  useEffect(() => {
    const newFields = CATEGORY_DEFINITIONS[selectedCategory]?.fields || [];
    setFieldsToRender(newFields);
    
    // Reseta o formData mantendo apenas os campos comuns + categoria
    if (!productToEdit) {
      setFormData({ category: selectedCategory });
    } else if (productToEdit.category !== selectedCategory) {
       // Se está editando e troca a categoria, limpa os campos específicos antigos
       const commonData = {
         id: productToEdit.id,
         category: selectedCategory,
         productName: productToEdit.productName,
         supplier: productToEdit.supplier,
       };
       setFormData(commonData);
    }

  }, [selectedCategory, productToEdit]);

  const handleChange = (e) => {
    const { name, value, type } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'number' ? (value ? Number(value) : '') : value
    }));
  };

  const handleCategoryChange = (e) => {
    const newCategory = e.target.value;
    setSelectedCategory(newCategory);
    handleChange(e); // Atualiza a categoria no formData também
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    /* REMOVIDO
    if (isSaving || !db || !userId) return;
    
    setIsSaving(true);
    
    try {
      if (productToEdit) {
        // Editando
        const docPath = `/artifacts/${appId}/users/${userId}/products/${productToEdit.id}`;
        await setDoc(doc(db, docPath), formData);
      } else {
        // Adicionando
        const collectionPath = `/artifacts/${appId}/users/${userId}/products`;
        await addDoc(collection(db, collectionPath), { ...formData, userId });
      }
      onClose();
    } catch (error) {
      console.error("Erro ao salvar produto:", error);
      // Aqui você setaria um estado de erro para o modal
    } finally {
      setIsSaving(false);
    }
    */
    if (isSaving) return;
    setIsSaving(true);

    try {
      if (productToEdit) {
        onSave({ ...formData, id: productToEdit.id });
      } else {
        onSave({ ...formData, id: crypto.randomUUID() });
      }
      onClose();
    } catch (error) {
      console.error("Erro ao salvar produto:", error);
    } finally {
      setIsSaving(false);
    }
  };
  
  // Renderiza um campo do formulário com base na sua definição
  const renderField = (fieldName) => {
    const fieldDef = FIELD_LABELS[fieldName];
    if (!fieldDef) {
      console.warn("Definição não encontrada para o campo:", fieldName);
      return null;
    }
    
    const commonProps = {
      id: fieldName,
      name: fieldName,
      value: formData[fieldName] || '',
      onChange: handleChange,
      className: "w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 bg-gray-800 text-white border-gray-700 placeholder-gray-500",
      placeholder: fieldDef.placeholder || '',
    };
    
    return (
      <div key={fieldName} className="col-span-1">
        <label htmlFor={fieldName} className="block text-sm font-medium text-gray-300 mb-1">
          {fieldDef.label}
        </label>
        {fieldDef.type === 'select' ? (
          <select {...commonProps}>
            <option value="">Selecione...</option>
            {fieldDef.options.map(opt => (
              <option key={opt} value={opt}>{opt}</option>
            ))}
          </select>
        ) : (
          <input 
            type={fieldDef.type}
            step={fieldDef.type === 'number' ? '0.01' : undefined}
            {...commonProps} 
          />
        )}
      </div>
    );
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 backdrop-blur-sm">
      <div className="bg-gray-900 rounded-lg shadow-2xl w-full max-w-3xl max-h-[90vh] flex flex-col">
        {/* Cabeçalho do Modal */}
        <div className="flex justify-between items-center p-6 border-b border-gray-700">
          <h2 className="text-2xl font-bold text-white">
            {productToEdit ? 'Editar Produto' : 'Adicionar Novo Produto'}
          </h2>
          <button onClick={onClose} className="p-1 rounded-full text-gray-400 hover:bg-gray-700 hover:text-gray-200">
            <X className="w-6 h-6" />
          </button>
        </div>
        
        {/* Formulário */}
        <form onSubmit={handleSubmit} className="flex-1 overflow-y-auto p-8">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {/* Seletor de Categoria (Sempre primeiro) */}
            <div className="col-span-1 md:col-span-2">
              <label htmlFor="category" className="block text-sm font-medium text-gray-300 mb-1">
                Categoria do Produto
              </label>
              <select
                id="category"
                name="category"
                value={selectedCategory}
                onChange={handleCategoryChange}
                className="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 bg-gray-800 text-white border-gray-700 font-medium"
              >
                {Object.keys(CATEGORY_DEFINITIONS).map(key => (
                  <option key={key} value={key}>{CATEGORY_DEFINITIONS[key].label}</option>
                ))}
              </select>
            </div>
            
            {/* Campos Dinâmicos */}
            {fieldsToRender.map(fieldName => renderField(fieldName))}

            {/* Campo especial 'addons' que só aparece se 'hasAddons' for 'Sim' */}
            {selectedCategory === 'Streaming' && formData.hasAddons === 'Sim' && renderField('addons')}
            
          </div>
        </form>

        {/* Rodapé do Modal */}
        <div className="flex justify-end items-center p-6 border-t bg-gray-800 border-gray-700 rounded-b-lg">
          <button
            type="button"
            onClick={onClose}
            className="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-500 mr-3"
            disabled={isSaving}
          >
            Cancelar
          </button>
          <button
            type="submit"
            onClick={handleSubmit} // Permite salvar clicando fora do form
            className={`px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors ${
              isSaving ? 'opacity-50 cursor-not-allowed' : ''
            }`}
            disabled={isSaving}
          >
            {isSaving ? 'Salvando...' : (productToEdit ? 'Salvar Alterações' : 'Adicionar Produto')}
          </button>
        </div>
      </div>
    </div>
  );
}

// --- Funções Utilitárias ---

/**
 * Formata uma string de data (YYYY-MM-DD) para (DD/MM/YYYY)
 */
function formatDate(dateString) {
  if (!dateString) return '-';
  try {
    const [year, month, day] = dateString.split('-');
    return `${day}/${month}/${year}`;
  } catch (e) {
    return dateString; // Retorna original se falhar
  }
}

